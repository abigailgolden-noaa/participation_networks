---
title: Make comparisons to better understand vessel-level and aggregate fisheries
  participation networks
author: "Jameal Samhouri"
date: "Written 9/1/2021. Last Run `r Sys.Date()`"
output: 
  html_document:
    df_print: paged
    toc: yes
    toc_depth: '5'
  pdf_document:
    highlight: haddock
    number_sections: yes
    toc: yes
    toc_depth: '3'
geometry: margin=1in
subtitle: Preparation for network analysis in CCIEA ESR
fontsize: 11pt
---

# Setup

<br>
```{r "setup", include=FALSE}
if(!require("here")) {install.packages("here")}
library(here)
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = here::here())

## start time for full script
script_start_time <- Sys.time()
```
<br>

This script requires the following packages. 
```{r packages, message=FALSE, warning=FALSE}
if(!require("tidyverse")) {install.packages("tidyverse")}
if(!require("lubridate")) {install.packages("lubridate")}
if(!require("ggplot2")) {install.packages("ggplot2")}
if(!require("igraph")) {install.packages("igraph")}
```
<br>

And calls the following functions:
```{r}
source("R/generate_participation_network.R") # this function is for vessel-level networks, summarized at the port or state scale
source("R/generate_participation_network_bulk.R") # this function is for aggregate networks, summarized at the port or state scale
source("R/color_network_nodes.R")
source("R/network_stats_functions.R")
source("R/calc_network_stats.R")
```
<br>

# User Inputs 

Select your directories.
```{r}
## location of fish ticket with metiers assigned, metier key for each port group
indir = '/Users/jameal.samhouri/Documents/CCIEA Networks/processed'

## output directory for igraph objects
outdir_ports = 'data/networks/participation_vessel_ports'
outdir_states = 'data/networks/participation_vessel_states'
outdir_ports_agg = 'data/networks/participation_agg_ports'
outdir_states_agg = 'data/networks/participation_agg_states'

## output directory for network viz
pngdir_ports = 'data/networks/participation_vessel_ports/plots'
pngdir_states = 'data/networks/participation_vessel_states/plots'
pngdir_ports_agg = 'data/networks/participation_agg_ports/plots'
pngdir_states_agg = 'data/networks/participation_agg_ports/plots'

## output file (including directory) for stat summaries
statdir = 'results/statistics'

## directory for species group key. not confidential
processdir <- "data/input"
```
<br>

Specify file name of the species groupings lookup key that contains labels for the network graphs.
```{r get_filenames}

myfile5 <- "spgrpn2_iea_key.csv"

```
<br>


Identify the crab years, port groups, and states that you would like to produce networks for. The port groups vector should include only those port groups which are present in the single data file produced with script 00. The states vector should include only those states which are present in the agid column of the fishtix data produced with script 00. 
```{r}
## (crab) years
years <- seq(2004,2019)

## IOPAC port groups
myports <- c("Puget Sound","North WA Coast","WA Coast","Other Coastal Washington","Astoria","Tillamook","Columbia River","Newport","Coos Bay","Brookings","Crescent City","Eureka","Morro Bay","Fort Bragg","Bodega Bay","San Francisco","San Diego","Monterey","Santa Barbara","Los Angeles","Unknown Ports" )

# wa_ports <- myports[1:4]
# or_ports <- myports[5:10]
# ca_ports <- myports[11:20]

focal_ports <- c("North WA Coast","Astoria","Fort Bragg", "Morro Bay")

## west coast states
mystates <- c("C", "O","W")

```
<br>

Some Dungeness crab landings may be recorded prior to the official opening date of the season as a part of domoic acid testing. We remove these landings because we are interested in flows of fishers between fisheries as a result of within-season activity.
```{r}
rm_crab = TRUE
```
<br>

For confidentiality, three or more vessels must be participating in a given fishery for that fishery to be included in the networks. To avoid inclusion of rare or minimal fishing activity, a given fishery must contribute to at least 10% of a vessel's seasonal revenue to be included in the network data. 

The cutoff values can be increased if more stringent fishery inclusion criteria are preferred, and the contribution cutoff may be decreased (i.e. for summaries over shorter temporal / smaller spatial scales).
```{r}

vessel_cutoff <- 3
contr_cutoff <- 0.10

```
<br>


Set these objects according to your user inputs from Scripts 1 and 3
```{r}
## the value of `k` for the k-nearest neighbor function
k <- 1

## the reference years first run through infomap
## for the cciea network analysis this does not matter because we use a prior sp groupings
ref_years <- c(2004,2005)
```
<br>


# Generate all networks


```{r}
for(y in years){
  if(y %in% ref_years){
    tmptix <- read.csv(paste0(indir,"/fish_tickets_crab", y, "_processed_for_networks.csv"), stringsAsFactors = FALSE) %>%
    filter(IOPAC %in% myports)
  } else{
    tmptix <- read.csv(paste0(indir,"/fish_tickets_crab", y, "_processed_for_networks.csv"), stringsAsFactors = FALSE) %>%
    filter(IOPAC %in% myports)
  }
  if(exists('fishtix')){
    fishtix <- rbind(fishtix, tmptix)
  } else{ fishtix <- tmptix }
}
rm(tmptix)

# some checks on species groups
unique(fishtix$SPGRPN2)
length(which(is.na(fishtix$SPGRPN2)))
unique(fishtix[which(is.na(fishtix$SPGRPN2)),]$spid)
unique(fishtix[which(is.na(fishtix$SPGRPN2)),]$year)
unique(fishtix[which(is.na(fishtix$SPGRPN2)),]$agid)
unique(fishtix[which(is.na(fishtix$SPGRPN2)),]$pcid)

```
<br>

Make sure that all dates are `Posixt` objects and species group labels are characters.
```{r}
#dates_df$odate <- mdy(dates_df$odate)
fishtix$tdate <- date(parse_date_time(fishtix$tdate, orders=c("ymd", "mdy")))
fishtix$SPGRPN2 = as.character(fishtix$SPGRPN2)
```
<br>

Node names
```{r}

#### Read in species group labels key ####
node_names <- read_csv(here::here(processdir,myfile5),
                       col_types = list(col_character(), col_character(), col_character()))

```
<br>

Read in 2019 data
```{r}
y=2019
tickets <- fishtix %>%
      filter(crab_year == y & IOPAC %in% focal_ports)

```
<br>

Summarize proportion revenue by species group for focal ports, before excluding any vessels or fisheries 
```{r}
fisheries <- tickets %>% 
  filter(drvid != 'NONE') %>%
  group_by(IOPAC, SPGRPN2, crab_year) %>% 
  summarise(revenue = sum(adj_revenue)) %>% 
  spread(SPGRPN2, revenue, fill = NA)

  fisheries <- as.data.frame(fisheries %>% select(-crab_year))
  # rownames(fisheries) <- fisheries$crab_year
  # fisheries$crab_year <- NULL
  
  # make a new df with annual % revenue from each metier for each fishery
  percent_fisheries <- cbind(fisheries[,1],
                             fisheries[,-1]/rowSums(fisheries[,-1], na.rm = T))
  colnames(percent_fisheries)[1] <- 'IOPAC'
  
  fisheries %>% knitr::kable()
  percent_fisheries %>% knitr::kable()

```
<br>

Now exclude fisheries that do not generate at least `$500` in revenue
```{r}

min_rev_indiv = 500

percent_fisheries_mat <- as.matrix(percent_fisheries[,-1])
percent_fisheries_mat[which(fisheries[,-1]<min_rev_indiv)] <- NA

percent_fisheries_min_rev_indiv <- cbind(fisheries[,1],as.data.frame(percent_fisheries_mat))  

rm(percent_fisheries_mat)
colnames(percent_fisheries_min_rev_indiv)[1] <- 'IOPAC'

  # for each fishery, set filtered_fisheries table value as "NA" for fisheries that don't generate at least min_rev_indiv in revenue annually.
fisheries_mat <- as.matrix(fisheries[,-1])
fisheries_mat[which(fisheries_mat<min_rev_indiv)] <- NA

fisheries_min_rev_indiv <- cbind(fisheries[,1],as.data.frame(fisheries_mat)) # was filtered_fisheries
colnames(fisheries_min_rev_indiv)[1] <- 'IOPAC'

rm(fisheries_mat) 

fisheries_min_rev_indiv %>% knitr::kable()
percent_fisheries_min_rev_indiv %>% knitr::kable()

```
<br>

Now exclude fisheries that do not have at least 3 vessels and those that do not contribute >=10% to aggregate port revenue.
```{r}


n_boats <- tickets %>% filter(drvid!='NONE') %>%
    group_by(IOPAC, crab_year, SPGRPN2) %>%
    summarise(n_boats = length(unique(drvid))) %>%
    group_by(IOPAC, SPGRPN2) %>%
    summarise(max_boats = max(n_boats))

fishery_df <- percent_fisheries_min_rev_indiv %>%
  pivot_longer(cols = 2:dim(percent_fisheries_min_rev_indiv)[2]) %>%
  rename(SPGRPN2 = "name", percent_contribution = "value")

fish_df <- left_join(fishery_df, n_boats, by = c('IOPAC','SPGRPN2'))
  
vessel_df <- fish_df %>%
  filter(
    max_boats >= vessel_cutoff & percent_contribution >= contr_cutoff
    )
    # ) %>%
    # select(IOPAC, SPGRPN2, max_boats)
  
vessel_df %>% knitr::kable()  
    

```
<br>

Now summarize fisheries using vessel-level approach

Summarize proportion revenue by vessel and species group for focal ports, before excluding any vessels or fisheries. Assume only 1 crab_year included. 
```{r}
boats <- tickets %>% 
  filter(drvid != 'NONE') %>%
  group_by(drvid, IOPAC, SPGRPN2) %>%
  summarise(revenue = sum(adj_revenue)) %>%
  pivot_wider(names_from=SPGRPN2, values_from=revenue, values_fill = NA) # if applying this for multiple crab_years code needs to crab_year added to group_by and below c(1:2) should be c(1:3)

percent_boats <- cbind(
  boats[,c(1:2)],
  boats[,-c(1:2)]/rowSums(boats[,-c(1:2)], na.rm = T)
)

# boats <- as.data.frame(boats)
# rownames(boats) <- paste(boats$drvid, boats$IOPAC, boats$crab_year, sep="_")
# boats$drvid <- NULL
# boats$crab_year <- NULL
# boats$IOPAC <- NULL
# 
# percent_boats <- boats/rowSums(boats, na.rm = T)

boats[1:10,] %>% knitr::kable()
percent_boats[1:10,] %>% knitr::kable()

```

Now exclude vessels that do not generate at least `$5000` in revenue annually, and fisheries that do not generate at least `$500` annually, at each port group.
```{r}

min_rev = 5000
min_rev_indiv = 500

# exclude vessels that do not generate at least `$5000` in revenue annually across all fisheries
if(any(rowSums(boats[,-c(1:2)],na.rm=T)<min_rev)){
  boats_min_rev <- boats[-which(rowSums(boats[,-c(1:2)], na.rm=T)<min_rev),]
} else {
   boats_min_rev <- boats 
  }

##### calculate percent contributions, then remove fisheries with below min_rev_indiv #####
percent_boats_min_rev <- cbind(
  boats_min_rev[,c(1:2)],
  boats_min_rev[,-c(1:2)]/rowSums(boats_min_rev[,-c(1:2)], na.rm = T)
)
percent_boats_mat <- as.matrix(percent_boats_min_rev[,-c(1:2)]) # make a new df with annual % revenue from each fishery for each boat
percent_boats_mat[which(boats_min_rev[,-c(1:2)]<min_rev_indiv)] <- NA # for each boat, set percent_boats table value as "NA" for fisheries that don't generate at least min_rev_indiv in revenue annually. 
percent_boats_min_rev_min_rev_indiv <- cbind(
  boats_min_rev[,c(1:2)], 
  as.data.frame(percent_boats_mat)
)
rm(percent_boats_mat)

# for each boat, set table value as "NA" for fisheries that don't generate at least min_rev_indiv in revenue annually.
boats_mat <- as.matrix(boats_min_rev[,-c(1:2)])
boats_mat[which(boats_min_rev[,-c(1:2)]<min_rev_indiv)] <- NA 
boats_min_rev_min_rev_indiv <- cbind(
  boats_min_rev[,c(1:2)], 
  as.data.frame(boats_mat)
)
rm(boats_mat)

boats_min_rev_min_rev_indiv[1:10,] %>% knitr::kable()
percent_boats_min_rev_min_rev_indiv[1:10,] %>% knitr::kable()


```
<br>

Now exclude fisheries that do not have at least 3 vessels and those that do not contribute a median >=10% to annual vessel revenue in each port.
```{r}

n_boats <- tickets %>% filter(drvid!='NONE') %>%
    group_by(IOPAC, crab_year, SPGRPN2) %>%
    summarise(n_boats = length(unique(drvid))) %>%
    group_by(IOPAC, SPGRPN2) %>%
    summarise(max_boats = max(n_boats))

# find median contribution of fisheries across vessels (with min_rev_indiv applied)
v_fishery_df <- percent_boats_min_rev_min_rev_indiv %>%
  pivot_longer(cols = 3:dim(percent_boats_min_rev_min_rev_indiv)[2]) %>%
  rename(SPGRPN2 = "name", percent_contribution = "value") %>%
  group_by(IOPAC, SPGRPN2) %>%
  summarise(
    median_percent_contribution = median(percent_contribution, na.rm = TRUE)
  )

v_fish_df <- left_join(v_fishery_df, n_boats, by = c('IOPAC','SPGRPN2'))
  
v_vessel_df <- v_fish_df %>%
  filter(
    max_boats >= vessel_cutoff & median_percent_contribution >= contr_cutoff
    ) 

v_vessel_df %>% knitr::kable()  
    

```
<br>

So finally, let's compare aggregate percent revenue contributions of each fishery to median annual vessel revenues. 

Note that some fisheries meet the cutoffs for inclusion in vessel-level networks but not in aggregate networks (therefore the value of 'port_level_percent_contribution' is listed as NA in the table below because those fisheries contribute <10% of aggregate port revenue annually), but the reverse is not true.
```{r}

compare_vessel_df <- left_join(v_vessel_df,vessel_df) %>%
  left_join(node_names) %>%
  rename(median_vessel_level_percent_contribution = median_percent_contribution, port_level_percent_contribution = percent_contribution, num_vessels= max_boats, fishery = species_group_2_label2) %>%
  select(IOPAC, fishery, median_vessel_level_percent_contribution, port_level_percent_contribution, fishery)

compare_vessel_df %>% knitr::kable()  
  

```
<br>

  
For vessel-level networks, generate_participation_network.R (lines 222-226) is basing node size (importance) on median % contribution to annual vessel revenue ('median_vessel_level_percent_contribution' in the table above) relative to the max median % contribution to annual vessel revenue in each network.

For aggregate networks, generate_participation_network_bulk.R (~lines 210-214) is basing node size (importance) on % contribution to annual port revenue ('port_level_percent_contribution' in the table above) relative to the max port revenue.

